<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>13 Years of Bad Game Code</title>

		<meta name="description" content="Developers hate him!">
		<meta name="author" content="Evan Todd">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="style.css" id="theme">
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background="#101a26">
					<h1>13 Years of Bad Game Code</h1>
					<small>
						Evan Todd<br />
						&#8592;&#8594;
					</small>
				</section>
				<section data-background="#158">
					<h1>Bad Code I've Worked With</h1>
					<ul>
						<li>Web 1.0 sites (PHP)</li>
						<li>Async webservers (Python, Javascript)</li>
						<li>Private cloud sysadmin stuff (shell)</li>
						<li>Declarative Service Orchestrationâ„¢ (Ruby)</li>
						<li>Mobile apps (Java, Javascript, Objective C, Swift)</li>
						<li>DirectX and VR (C#)</li>
						<li>OpenGL (C++, Python, Javascript)</li>
						<li>Windows, Linux, OS X, iOS, Android, HTML5</li>
					</ul>
					<p class="fragment">Everything is Terrible</p>
				</section>
				<section data-background="#185">
					<h1>Have you ever done this?</h1>
					<ol>
						<li class="fragment">Open an old project from a few years back</li>
						<li class="fragment"><span class="code">oh no</span></li>
						<li class="fragment"><span class="code">i've made a huge mistake</span></li>
						<li class="fragment">Close project</li>
						<li class="fragment">Delete project</li>
					</ol>
				</section>
				<section data-background="#000">
					<h1>2004</h1>
					<img class="fragment" src="img/red-moon.png" />
				</section>
				<section data-background="#101a26">
					<h1>Switching Weapons</h1>
					<pre class="fragment"><code data-trim class="java">
long changeTime = 500; //! magic number; no comment
PolygonGroup weaponGroup; //! unnecessary state variable
public void nextWeapon() {
	super.nextWeapon(); //! we'll get to this later
	weaponGroup = group.getGroup("gun");
	if(weaponGroup != null) { //! defensive coding
		//! more state. more magic numbers.
		weaponGroup.xform.velocityAngleX.set(-.003f, 250);
	}
	changeTime = 250; //! another magic number
	changing = true; //! could infer this from changeTime
}
				</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>It Gets Worse</h1>
					<pre class="fragment"><code data-trim class="java">
boolean changing = false; //! unnecessary state variable
public void updateAnimation(long eTime) {
	if(group.getGroup("gun") == null) { //! defensive coding
		//! again, not sure exactly when this will happen
		group.addGroup((PolygonGroup)gun.clone());
	}
	changeTime -= eTime;
	if(changing &amp;&amp; changeTime <= 0) {
		group.removeGroup("gun");
		group.addGroup((PolygonGroup)gun.clone());
		//! what if one time I forget to do this next line?
		weaponGroup = group.getGroup("gun");
		//! more state. more magic numbers.
		weaponGroup.xform.velocityAngleX.set(.003f, 250);
		changing = false;
	}
}
					</code></pre>
				</section>
				<section data-background="#822">
					<h1>The Worst Part</h1>
					<ul>
						<li class="fragment">changeTime</li>
						<li class="fragment">changing</li>
						<li class="fragment">weaponGroup</li>
						<li class="fragment">weaponGroup.xform.velocityAngleX</li>
					</ul>
					<p class="fragment left">
						Feels like something's missing...
					</p>
					<p class="fragment left">
						Even with all that state, there's still another variable somewhere else tracking the current weapon!
					</p>
				</section>
				<section data-background="#822">
					<h1>The Even Worse Part</h1>
					<p class="fragment">
						I never implemented different weapon models.
					</p>
					<p class="fragment">
						Remove your dead code! It's a liability.
					</p>
				</section>
				<section data-background="#158">
					<h1>How to Improve</h1>
					<aside class="notes">
						<ul>
							<li>Remove duplicated state. It's another liability. You could do it with two variables:
								<ul>
									<li>weaponSwitchTimer</li>
									<li>weaponCurrent</li>
								</ul>
							</li>
							<li>Explicitly initialize everything in deterministic order. Your job is to plan ahead, because the computer can't do that.</li>
							<li>Turn magic numbers into constants.</li>
							<li>Handle errors. Either crash or notify the user and gracefully recover.</li>
							<li>Write some darn comments.</li>
							<li>Use zero initialization if possible.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Zero Initialization</h1>
					<pre><code data-trim class="fragment java">
public class Ally extends GameObject {
	boolean noenemies = true; //! why
}
					</pre></code>
					<aside class="notes">
						<ul>
							<li>If possible, the default state of your object should be all zeroes.</li>
							<li>Makes everything more intuitive.</li>
							<li>Can also be more efficient in some cases.</li>
							<li>Name your booleans positively to avoid writing things like:
								<pre><code data-trim class="java">
if (!noenemies) { /* ... */ }
								</pre></code>
							</li>
						</ul>
					</aside>
				</section>
				<section data-background="#000">
					<h1>2005-2006</h1>
					<img class="fragment" src="img/vivid.png" />
				</section>
				<section data-background="#101a26">
					<h1>Meshes</h1>
					<pre class="fragment"><code data-trim class="cpp">
class Mesh {
public:
	static std::list&lt;Mesh*&gt; meshes; // Static list of meshes; used for caching and rendering
	Mesh(LPCSTR file); // Loads the x file specified
	Mesh();
	Mesh(const Mesh& vMesh);
	~Mesh();
	void LoadMesh(LPCSTR xfile); // Loads the x file specified
	void DrawSubset(DWORD index); // Draws the specified subset of the mesh
	DWORD GetNumFaces(); // Returns the number of faces (triangles) in the mesh
	DWORD GetNumVertices(); // Returns the number of vertices (points) in the mesh
	DWORD GetFVF(); // Returns the Flexible Vertex Format of the mesh
	int GetNumSubsets(); // Returns the number of subsets (materials) in the mesh
	Transform transform; // World transform
	std::vector&lt;Material&gt;* GetMaterials(); // Gets the list of materials in this mesh
	std::vector&lt;Cell*&gt;* GetCells(); // Gets the list of cells this mesh is inside
	D3DXVECTOR3 GetCenter(); // Gets the center of the mesh
	float GetRadius(); // Gets the distance from the center to the outermost vertex of the mesh
	bool IsAlpha(); // Returns true if this mesh has alpha information
	bool IsTranslucent(); // Returns true if this mesh needs access to the back buffer
	void AddCell(Cell* cell); // Adds a cell to the list of cells this mesh is inside
	void ClearCells(); // Clears the list of cells this mesh is inside
protected:
	ID3DXMesh* d3dmesh; // Actual mesh data
	LPCSTR filename; // Mesh file name; used for caching
	DWORD numSubsets; // Number of subsets (materials) in the mesh
	std::vector&lt;Material&gt; materials; // List of materials; loaded from X file
	std::vector&lt;Cell*&gt; cells; // List of cells this mesh is inside
	D3DXVECTOR3 center; // The center of the mesh
	float radius; // The distance from the center to the outermost vertex of the mesh
	bool alpha; // True if this mesh has alpha information
	bool translucent; // True if this mesh needs access to the back buffer
	void SetTo(Mesh* mesh);
}
					</pre></code>
				</section>
				<section data-background="#101a26">
					<h1>You Learned: "Comments"!</h1>
					<div class="fragment">
						<p class="left">When someone tells you "comments are good", you end up writing a bunch of comments like this:</p>
						<pre><code data-trim class="cpp">
D3DXVECTOR3 GetCenter(); // Gets the center of the mesh
						</pre></code>
					</div>
				</section>
				<section data-background="#101a26">
					<h1>You Learned: "Object-Oriented Programming"!</h1>
					<pre class="fragment"><code data-trim class="cpp">
// Returns true if this mesh has alpha information
bool Mesh::IsAlpha() {
	return alpha;
}
// Returns true if this mesh needs access to the back buffer
bool Mesh::IsTranslucent() {
	return translucent;
}
// Returns the number of faces (triangles) in the mesh
DWORD Mesh::GetNumFaces() {
	return d3dmesh-&gt;GetNumFaces();
}
// Returns the number of vertices (points) in the mesh
DWORD Mesh::GetNumVertices() {
	return d3dmesh-&gt;GetNumVertices();
}
// ...
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Unloading a Mesh</h1>
					<pre class="fragment"><code data-trim class="cpp">
std::list&lt;Mesh*&gt; Mesh::meshes;

Mesh::~Mesh() {
	// Iterate through all the meshes
	std::list&lt;Mesh*&gt;::iterator i = meshes.begin();
	while(i != meshes.end()) { //! deleting all meshes is O(n^2)
		if(*i == this) {
			meshes.erase(i); // Erase this object from the list so we don't have a stray pointer in the mesh list
			break;
		}
		i++;
	} //! unclear who owns this mesh
	materials.clear();
	vvd::Release&lt;ID3DXMesh*&gt;(d3dmesh); // Release the mesh data
}
					</pre></code>
				</section>
				<section data-background="#822">
					<h1>Problems</h1>
					<aside class="notes">
						<ul>
							<li>Poor OOP design leads to weird unintuitive patterns, like an object "deleting itself" or "serializing itself".</li>
							<li>90% of comments are useless. Another liability.</li>
							<li>Getters and setters.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>How to Improve</h1>
					<aside class="notes">
						<ul>
							<li>Think of a mesh as inert data. It has no functionality.</li>
							<li>Instead of making each mesh super smart, write a resource manager.</li>
							<li>That clears up who's responsible for the mesh.</li>
							<li>Make all fields public.</li>
							<li>Delete comments that explain what the code does.</li>
							<li>Write comments that explain why.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#000">
					<h1>2007-2008</h1>
					<p class="fragment">PHP dark ages</p>
					<img class="fragment" src="img/php.png" />
				</section>
				<section data-background="#000">
					<h1>2009-2010</h1>
					<img class="fragment" src="img/a3p.jpg" />
				</section>
				<section data-background="#101a26">
					<h1>Naming</h1>
					<pre class="fragment"><code data-trim class="python">
class TeamEntityController(Controller):

	def buildSpawnPacket(self):
		# ...
	
	def readSpawnPacket(aiWorld, entityGroup, iterator, entity = None):
		# ...
	
	def serverUpdate(self, aiWorld, entityGroup, packetUpdate):
		# ...

	def clientUpdate(self, aiWorld, entityGroup, data = None):
		# ...
					</pre></code>
				</section>
				<section data-background="#101a26">
					<h1>Ordering: General -> Specific</h1>
					<p>Helps with code completion and organization.</p>
					<pre><code data-trim class="python">
class TeamEntityController(Controller):

	def packetSpawnBuild(self):
		# ...
	
	def packetSpawnRead(aiWorld, entityGroup, iterator, entity = None):
		# ...
	
	def updateServer(self, aiWorld, entityGroup, packetUpdate):
		# ...

	def updateClient(self, aiWorld, entityGroup, data = None):
		# ...
					</pre></code>
				</section>
				<section data-background="#822">
					<h1>Globals</h1>
					<aside class="notes">
						<ul>
							<li>Use case: in update function, need to query for an entity.</li>
							<li>Common wisdom: globals are evil</li>
							<li>You should pass everything you need as function parameters</li>
							<li>Singletons are okay</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>What's Wrong with Globals?</h1>
					<aside class="notes">
						<ul>
							<li>Can lead to spaghetti code</li>
							<li>Function "A" can break a completely unrelated function "B" by modifying global state</li>
							<li>Therefore, changing function "A" may require a change in function "B".</li>
							<li>Moral of the story: avoid globals</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>What Happens When You Try to Avoid Globals</h1>
					<div class="fragment">
						<p class="left">You pass everything as parameters</p>
						<pre><code data-trim class="python">
def serverUpdate(self, aiWorld, entityGroup, packetUpdate):
	# ...
						</code></pre>
					</div>
				</section>
				<section data-background="#158">
					<h1>This Will Be Great</h1>
					<p>I could have multiple EntityGroups! Multiple worlds!</p>
				</section>
				<section data-background="#822">
					<h1>Reality</h1>
					<aside class="notes">
						<ul>
							<li>If every object has access to it, it's still a global. You're just lying to yourself.</li>
							<li>YAGNI (You Aren't Gonna Need It). How many games need multiple, simultaneous worlds?</li>
							<li>When you add a new system, you'll be too lazy to edit every update function and pass it as another parameter.</li>
							<li>Instead, you'll tack it on to one of the existing objects you pass in.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>What About Singletons?</h1>
					<pre class="fragment"><code data-trim class="java">
class EntityFactory
{
	public static EntityFactory Instance()
	{
		static EntityFactory i = null;
		if (i == null)
			i = EntityFactory();
		return i;
	}
}

EntityFactory.Instance().DoThing();
					</pre></code>
					<p class="fragment">It's technically not a global!</p>
				</section>
				<section data-background="#822">
					<h1>Singletons Are Strictly Worse Than Globals</h1>
					<aside class="notes">
						<ul>
							<li>It's still a global. You're just lying to yourself.</li>
							<li>You don't know when a singleton will be initialized.</li>
							<li>Globals have a well-defined initialization time.</li>
							<li>Every time you access a singleton, it's a branch.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Another Solution (2010)</h1>
					<pre class="fragment"><code data-trim class="csharp">
public class Component
{
	protected Main main;
}

public class FooComponent : Component
{
	void Bar()
	{
		this.main.DoThing();
	}
}
					</code></pre>
					<aside class="notes">
						<ul>
							<li>Wanted to avoid globals</li>
							<li>Already tried parameter passing</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>It Is a Global</h1>
					<aside class="notes">
						<ul>
							<li>Memory wasted storing pointers</li>
							<li>Everything still has access to everything</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Just Use Globals</h1>
					<aside class="notes">
						<ul>
							<li>Real problem is code interdependence.</li>
							<li>Most gameplay code is necessarily interdependent.</li>
							<li>Think of a game as a series of systems with well-defined boundaries. AI, graphics, etc.</li>
							<li>Gameplay code constitutes its own system.</li>
							<li>Good way to separate system: put it on a thread w/ communication protocol.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Boolean Parameters</h1>
					<pre class="fragment"><code data-trim class="python">
class ObjectEntity:
	# ...
	def delete(self, entityGroup, killed = False, localDelete = True):
		"""Schedules this ObjectEntity to be cleared and removed from the given EntityGroup."""
		if self.active:
			self.active = False
			self.killed = killed #! never conflate deleting and killing
			if localDelete: #! this should be a separate method
				entityGroup.deleteEntity(self, killed)
			else:
				entityGroup.removeEntity(self)
			#! what if I call deleteEntity without calling entity.delete?
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Boolean Parameters</h1>
					<pre class="fragment"><code data-trim class="python">
class EntityGroup:
	def deleteLocal(self, e):
		# ...

	def deleteRemote(self, e):
		# ...

	def killLocal(self, e):
		# ...

	def killRemote(self, e):
		# ...
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Another Option: Flags</h1>
					<pre class="fragment"><code data-trim class="cpp">
entity_group.remove(e, EntityDeleteLocal | EntityDeleteKilled);
					</code></pre>
					<p class="fragment">Be careful, these can get out of hand</p>
				</section>
				<section data-background="#185">
					<h1>Debugging</h1>
					<aside class="notes">
						<ul>
							<li>Add a console</li>
							<li>Load level command</li>
							<li>Slow motion command to debug moving stuff</li>
							<li>Learn to use disassembly view</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Debugging</h1>
					<p class="left">Add something like this to your game loop:</p>
					<pre><code data-trim class="cpp">
if (keys[KEY_F5]) { assert(false); }
					</code></pre>
				</section>
				<section data-background="#000">
					<h1>2010 - 2015</h1>
					<img class="fragment" src="img/lemma.jpg" />
				</section>
				<section data-background="#158">
					<h1>Data Binding</h1>
					<aside class="notes">
						<ul>
							<li>Examples: MVVM, React, Angular</li>
							<li>The dream: set a variable, textbox updates automatically</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>The Dream</h1>
					<pre class="fragment"><code data-trim class="csharp">
public class TextElement : UIComponent
{
	public Property&lt;string&gt; Text = new Property&lt;string&gt; { Value = "" };
}

public class Player
{
	public Property&lt;string&gt; Name = new Property&lt;string&gt; { Value = "Ryu" };
}

label.add(new Binding&lt;string&gt;(label.Text, player.Name));
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Red Flags</h1>
					<pre><code data-trim class="csharp">
public class Property&lt;Type&gt; : IProperty
{
	protected Type _value;
	protected List&lt;IPropertyBinding&gt; bindings; //! inefficient

	public Type Value
	{
		get { return this._value; }
		set
		{
			this._value = value;
			//! weird loop necessary due to binding changes
			for (int i = this.bindings.Count - 1; i &gt;= 0; i = Math.Min(this.bindings.Count - 1, i - 1))
				this.bindings[i].OnChanged(this);
		}
	}
}
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Taking Things Too Far</h1>
					<pre><code data-trim class="csharp">
jump.Add(new Binding&lt;bool&gt;(jump.Crouched, player.Character.Crouched));
jump.Add(new TwoWayBinding&lt;bool&gt;(player.Character.IsSupported, jump.IsSupported));
jump.Add(new TwoWayBinding&lt;bool&gt;(player.Character.HasTraction, jump.HasTraction));
jump.Add(new TwoWayBinding&lt;Vector3&gt;(player.Character.LinearVelocity, jump.LinearVelocity));
jump.Add(new TwoWayBinding&lt;BEPUphysics.Entities.Entity&gt;(jump.SupportEntity, player.Character.SupportEntity));
jump.Add(new TwoWayBinding&lt;Vector3&gt;(jump.SupportVelocity, player.Character.SupportVelocity));
jump.Add(new Binding&lt;Vector2&gt;(jump.AbsoluteMovementDirection, player.Character.MovementDirection));
jump.Add(new Binding&lt;WallRun.State&gt;(jump.WallRunState, wallRun.CurrentState));
jump.Add(new Binding&lt;float&gt;(jump.Rotation, rotation.Rotation));
jump.Add(new Binding&lt;Vector3&gt;(jump.Position, transform.Position));
jump.Add(new Binding&lt;Vector3&gt;(jump.FloorPosition, floor));
jump.Add(new Binding&lt;float&gt;(jump.MaxSpeed, player.Character.MaxSpeed));
jump.Add(new Binding&lt;float&gt;(jump.JumpSpeed, player.Character.JumpSpeed));
jump.Add(new Binding&lt;float&gt;(jump.Mass, player.Character.Mass));
jump.Add(new Binding&lt;float&gt;(jump.LastRollKickEnded, rollKickSlide.LastRollKickEnded));
jump.Add(new Binding&lt;Voxel&gt;(jump.WallRunMap, wallRun.WallRunVoxel));
jump.Add(new Binding&lt;Direction&gt;(jump.WallDirection, wallRun.WallDirection));
jump.Add(new CommandBinding&lt;Voxel, Voxel.Coord, Direction&gt;(jump.WalkedOn, footsteps.WalkedOn));
jump.Add(new CommandBinding(jump.DeactivateWallRun, (Action)wallRun.Deactivate));
jump.FallDamage = fallDamage;
jump.Predictor = predictor;
jump.Bind(model);
jump.Add(new TwoWayBinding&lt;Voxel&gt;(wallRun.LastWallRunMap, jump.LastWallRunMap));
jump.Add(new TwoWayBinding&lt;Direction&gt;(wallRun.LastWallDirection, jump.LastWallDirection));
jump.Add(new TwoWayBinding&lt;bool&gt;(rollKickSlide.CanKick, jump.CanKick));
jump.Add(new TwoWayBinding&lt;float&gt;(player.Character.LastSupportedSpeed, jump.LastSupportedSpeed));

wallRun.Add(new Binding&lt;bool&gt;(wallRun.IsSwimming, player.Character.IsSwimming));
wallRun.Add(new TwoWayBinding&lt;Vector3&gt;(player.Character.LinearVelocity, wallRun.LinearVelocity));
wallRun.Add(new TwoWayBinding&lt;Vector3&gt;(transform.Position, wallRun.Position));
wallRun.Add(new TwoWayBinding&lt;bool&gt;(player.Character.IsSupported, wallRun.IsSupported));
wallRun.Add(new CommandBinding(wallRun.LockRotation, (Action)rotation.Lock));
wallRun.Add(new CommandBinding&lt;float&gt;(wallRun.UpdateLockedRotation, rotation.UpdateLockedRotation));
vault.Add(new CommandBinding(wallRun.Vault, delegate() { vault.Go(true); }));
wallRun.Predictor = predictor;
wallRun.Add(new Binding&lt;float&gt;(wallRun.Height, player.Character.Height));
wallRun.Add(new Binding&lt;float&gt;(wallRun.JumpSpeed, player.Character.JumpSpeed));
wallRun.Add(new Binding&lt;float&gt;(wallRun.MaxSpeed, player.Character.MaxSpeed));
wallRun.Add(new TwoWayBinding&lt;float&gt;(rotation.Rotation, wallRun.Rotation));
wallRun.Add(new TwoWayBinding&lt;bool&gt;(player.Character.AllowUncrouch, wallRun.AllowUncrouch));
wallRun.Add(new TwoWayBinding&lt;bool&gt;(player.Character.HasTraction, wallRun.HasTraction));
wallRun.Add(new Binding&lt;float&gt;(wallRun.LastWallJump, jump.LastWallJump));
wallRun.Add(new Binding&lt;float&gt;(player.Character.LastSupportedSpeed, wallRun.LastSupportedSpeed));
player.Add(new Binding&lt;WallRun.State&gt;(player.Character.WallRunState, wallRun.CurrentState));

input.Bind(rollKickSlide.RollKickButton, settings.RollKick);
rollKickSlide.Add(new Binding&lt;bool&gt;(rollKickSlide.EnableCrouch, player.EnableCrouch));
rollKickSlide.Add(new Binding&lt;float&gt;(rollKickSlide.Rotation, rotation.Rotation));
rollKickSlide.Add(new Binding&lt;bool&gt;(rollKickSlide.IsSwimming, player.Character.IsSwimming));
rollKickSlide.Add(new Binding&lt;bool&gt;(rollKickSlide.IsSupported, player.Character.IsSupported));
rollKickSlide.Add(new Binding&lt;Vector3&gt;(rollKickSlide.FloorPosition, floor));
rollKickSlide.Add(new Binding&lt;float&gt;(rollKickSlide.Height, player.Character.Height));
rollKickSlide.Add(new Binding&lt;float&gt;(rollKickSlide.MaxSpeed, player.Character.MaxSpeed));
rollKickSlide.Add(new Binding&lt;float&gt;(rollKickSlide.JumpSpeed, player.Character.JumpSpeed));
rollKickSlide.Add(new Binding&lt;Vector3&gt;(rollKickSlide.SupportVelocity, player.Character.SupportVelocity));
rollKickSlide.Add(new TwoWayBinding&lt;bool&gt;(wallRun.EnableEnhancedWallRun, rollKickSlide.EnableEnhancedRollSlide));
rollKickSlide.Add(new TwoWayBinding&lt;bool&gt;(player.Character.AllowUncrouch, rollKickSlide.AllowUncrouch));
rollKickSlide.Add(new TwoWayBinding&lt;bool&gt;(player.Character.Crouched, rollKickSlide.Crouched));
rollKickSlide.Add(new TwoWayBinding&lt;bool&gt;(player.Character.EnableWalking, rollKickSlide.EnableWalking));
rollKickSlide.Add(new TwoWayBinding&lt;Vector3&gt;(player.Character.LinearVelocity, rollKickSlide.LinearVelocity));
rollKickSlide.Add(new TwoWayBinding&lt;Vector3&gt;(transform.Position, rollKickSlide.Position));
rollKickSlide.Predictor = predictor;
rollKickSlide.Bind(model);
rollKickSlide.VoxelTools = voxelTools;
rollKickSlide.Add(new CommandBinding(rollKickSlide.DeactivateWallRun, (Action)wallRun.Deactivate));
rollKickSlide.Add(new CommandBinding(rollKickSlide.Footstep, footsteps.Footstep));
					</code></pre>
				</section>
				<section data-background="#822">
					<h1>Problem: Initialization</h1>
					<aside class="notes">
						<ul>
							<li>Infinite loops</li>
							<li>Initialization order is important</li>
							<li>Never figured this out</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>Problem: Animation</h1>
					<aside class="notes">
						<ul>
							<li>Difficult to animate from one state to another</li>
							<li>Netflix's actual React solution: disable, animate, then re-enable</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Binding On/Off Switch</h1>
					<pre><code data-trim class="csharp">
class Binding&lt;T&gt;
{
	public bool Enabled;
}
					</code></pre>
					<aside class="notes">
						<ul>
							<li>Goal of data binding is to reduce state</li>
							<li>But every property has a LIST of bindings and every binding has a boolean</li>
							<li>How can we reduce this state?</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Solution</h1>
					<pre><code data-trim class="csharp">
class Binding&lt;T&gt;
{
	public Property&lt;bool&gt; Enabled = new Property&lt;bool&gt; { Value = true };
}
					</code></pre>
				</section>
				<section data-background="#822">
					<h1>Data Binding</h1>
					<p>So close but so far</p>
					<aside class="notes">
						<ul>
							<li>Goal is to reduce state, like functional programming</li>
							<li>Actually creates more state</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>How to Improve</h1>
					<aside class="notes">
						<ul>
							<li>Separate behavior and data</li>
							<li>Write pure functions</li>
							<li>It should be a pain to create state</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Closures</h1>
					<pre class="fragment"><code data-trim class="csharp">
bool state = false;
var toggle = Button();
toggle.OnClick = delegate()
{
	state = !state;
	toggle.Color = state ? Color.Red : Color.Blue;
};
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Taking Things Too Far</h1>
					<pre><code data-trim class="csharp">
Func&lt;Property&lt;PCInput.PCInputBinding&gt;, string, bool, bool, Container&gt; addInputSetting = delegate(Property&lt;PCInput.PCInputBinding&gt; setting, string display, bool allowGamepad, bool allowMouse)
{
	this.inputBindings.Add(setting);
	Container button = this.main.UIFactory.CreatePropertyButton&lt;PCInput.PCInputBinding&gt;(display, setting);
	this.resizeToMenu(button);
	button.Add(new CommandBinding(button.MouseLeftUp, delegate()
	{
		PCInput.PCInputBinding originalValue = setting;
		setting.Value = new PCInput.PCInputBinding();
		this.main.UI.EnableMouse.Value = false;
		input.GetNextInput(delegate(PCInput.PCInputBinding binding)
		{
			if (binding.Key == Keys.Escape)
				setting.Value = originalValue;
			else
			{
				PCInput.PCInputBinding newValue = new PCInput.PCInputBinding();
				newValue.Key = originalValue.Key;
				newValue.MouseButton = originalValue.MouseButton;
				newValue.GamePadButton = originalValue.GamePadButton;

				if (binding.Key != Keys.None)
				{
					newValue.Key = binding.Key;
					newValue.MouseButton = PCInput.MouseButton.None;
				}
				else if (allowMouse && binding.MouseButton != PCInput.MouseButton.None)
				{
					newValue.Key = Keys.None;
					newValue.MouseButton = binding.MouseButton;
				}

				if (allowGamepad)
				{
					if (binding.GamePadButton != 0)
						newValue.GamePadButton = binding.GamePadButton;
				}
				else
					newValue.GamePadButton = 0;

				setting.Value = newValue;
			}
			this.main.UI.EnableMouse.Value = true;
		});
	}));
	controlsList.Children.Add(button);
	return button;
};
					</code></pre>
				</section>
				<section data-background="#822">
					<h1>Problems</h1>
					<aside class="notes">
						<ul>
							<li>
								Capturing local variables:
								<ul>
									<li>Moves stuff from stack to heap</li>
									<li>Can't debug state</li>
									<li>Too easy to create state</li>
								</ul>
							</li>
							<li>
								Capturing other stuff:
								<ul>
									<li>Retain cycles</li>
									<li>Again, behavior and state are too closely tied</li>
								</ul>
							</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>How to Improve</h1>
					<aside class="notes">
						<ul>
							<li>Don't use closures</li>
							<li>Again, separate behavior and data</li>
							<li>Closures are too "clever"; keep things simple</li>
							<li>You should be fully aware of the evil you're doing when you add state</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Entity Component System</h1>
				</section>
				<section data-background="#822">
					<h1>Object-Oriented</h1>
					<ul class="blank">
						<li>idClass
						<ul class="blank">
							<li>idEntity
							<ul class="blank">
								<li>idAnimatedEntity
								<ul class="blank">
									<li>idWeapon</li>
									<li>idAFEntity_Base
									<ul class="blank">
										<li>idAFEntity_ClawFourFingers</li>
										<li>idAFEntity_Vehicle
										<ul class="blank">
											<li>idAFEntity_VehicleFourWheels</li>
											<li>idAFEntity_VehicleSixWheels</li>
										</ul>
										</li>
										<li>idAFEntity_Gibbable
										<ul class="blank">
											<li>idAFEntity_WithAttachedHead</li>
											<li>idActor
											<ul class="blank">
												<li>idPlayer</li>
												<li>idAI</li>
											</ul>
										</ul>
										</li>
									</ul>
									</li>
								</ul>
								</li>
							</ul>
							</li>
						</ul>
						</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>Problem: functionality ends up in base classes</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Components</h1>
					<ul class="blank">
						<li>idPlayer
						<ul class="blank">
							<li>idTransform</li>
							<li>idHealth</li>
							<li>idAnimatedModel</li>
							<li>idAnimator</li>
							<li>idRigidBody</li>
							<li>idBipedalCharacterController</li>
							<li>idPlayerController</li>
						</ul>
						</li>

						<li>idAFEntity_VehicleFourWheels
						<ul class="blank">
							<li>idTransform</li>
							<li>idAnimatedModel</li>
							<li>idRigidBody</li>
							<li>idFourWheelController</li>
						</ul>
						</li>

						<li>...</li>
					</ul>
					<aside class="notes">
						<ul>
							<li>Composition over inheritance</li>
							<li>I read about this and went overboard with it</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Entity Component System</h1>
				</section>
				<section data-background="#822">
					<h1>Entity Component <small style="font-size: 0.5em">System</small></h1>
				</section>
				<section data-background="#158">
					<h1><small style="font-size: 0.5em">Entity Component</small> System</h1>
				</section>
				<section data-background="#101a26">
					<h1>Extensibility</h1>
					<pre class="fragment"><code data-trim class="csharp">
public class Component&lt;MainClass&gt; : Bindable, IComponent
	where MainClass : BaseMain
{
	protected MainClass main;
}

public class FooComponent : Component&lt;Main&gt;
{
}
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>YAGNI</h1>
					<aside class="notes">
						<p>The more abstract you make a system, the less you're going to want to reuse it in the future.</p>
					</aside>
				</section>
				<section data-background="#185">
					<h1>Takeaway</h1>
					<ul>
						<li class="fragment">Separate behavior and data</li>
						<li class="fragment">Write pure functions as much as possible</li>
						<li class="fragment">Write the client code first</li>
						<li class="fragment">Write boring, straightforward code that does what's necessary and no more</li>
						<li class="fragment">Try not to be clever</li>
					</ul>
				</section>
				<section data-background="#158">
					<h1>Disclaimer</h1>
					<ul>
						<li class="fragment">Only a Sith deals in absolutes.</li>
						<li class="fragment">Never say never.</li>
						<li class="fragment">Avoid dogma.</li>
						<li class="fragment">Avoid holy wars.</li>
						<li class="fragment">Tabs are better than spaces.</li>
					</ul>
				</section>
				<section data-background="#185">
					<h1>Thank you!</h1>
					<p><a href="https://etodd.github.io/bad-code">etodd.github.io/bad-code</a></p>
					<p><a href="http://etodd.io/">etodd.io</a></p>
				</section>
			</div>
		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>
		<script>
			Reveal.initialize(
			{
				controls: false,
				progress: true,
				history: true,
				center: true,
				transition: 'slide',
				backgroundTransition: 'slide',
				transitionSpeed: 'superfast',
				dependencies:
				[
					{
						src: 'reveal.js/plugin/highlight/highlight.js',
						async: false,
						callback: function()
						{
							hljs.initHighlighting();

							var comments = document.querySelectorAll('.hljs-comment');
							for (var i = 0; i < comments.length; i++)
							{
								for (var j = 1; j < 5; j++)
								{
									var code = comments[i].innerText.substr(j, 1);
									if (code === '!')
										comments[i].classList.add('bad');
									if (code === '!' || code === '@')
									{
										comments[i].classList.add('fragment');
										break;
									}
								}
							}
						}
					},
					{ src: 'reveal.js/plugin/notes/notes.js', async: false },
				],
			});

			if (window.location.search.match(/print-pdf/gi))
				$('head').append($('<link rel="stylesheet" type="text/css" href="reveal.js/css/print/pdf.css" />'));
		</script>
	</body>
</html>
