<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>13 Years of Bad Game Code</title>

		<meta name="description" content="Developers hate him!">
		<meta name="author" content="Evan Todd">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="style.css" id="theme">
	</head>

	<body>
		<div class="reveal">
			<div class="slides">
				<section data-background="#000">
					<h1>13 Years of Bad Game Code</h1>
					<small>
						Evan Todd<br />
						&#8592;&#8594;
					</small>
				</section>
				<section data-background="#158">
					<h1>Bad Code I've Worked With</h1>
					<ul>
						<li>Web 1.0 sites (PHP)</li>
						<li>Async webservers (Python, Javascript)</li>
						<li>Private cloud sysadmin stuff (shell)</li>
						<li>Declarative Service Orchestrationâ„¢ (Ruby)</li>
						<li>Mobile apps (Java, Javascript, Objective C, Swift)</li>
						<li>DirectX and VR (C#)</li>
						<li>OpenGL (C++, Python, Javascript)</li>
						<li>Windows, Linux, OS X, iOS, Android, HTML5</li>
					</ul>
					<p class="fragment">Everything is Terrible</p>
				</section>
				<section data-background="#185">
					<h1>Have you ever done this?</h1>
					<ol>
						<li class="fragment">Open an old project from a few years back</li>
						<li class="fragment"><span class="code">oh no</span></li>
						<li class="fragment"><span class="code">i've made a huge mistake</span></li>
						<li class="fragment">Close project</li>
						<li class="fragment">Delete project</li>
					</ol>
					<aside class="notes">
						<ul>
							<li>What you're about to see is real</li>
							<li>NSFW warning</li>
						</ul>
					</aside>
				</section>
				<section data-background="#000">
					<h1>2004</h1>
					<img class="fragment" src="img/red-moon.png" />
					<aside class="notes">
						<ul>
							<li>Mostly copied out of a book</li>
							<li>The parts that weren't were atrocious</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Switching Weapons</h1>
					<pre class="fragment"><code data-trim class="java">
long changeTime = 500;
PolygonGroup weaponGroup;
boolean changing = false;
public void nextWeapon() {
	super.nextWeapon();
	weaponGroup = group.getGroup("gun");
	if(weaponGroup != null) { //! defensive coding
		weaponGroup.xform.velocityAngleX.set(-.003f, 250);
	}
	changeTime = 250;
	changing = true;
}
				</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>It Gets Worse</h1>
					<pre class="fragment"><code data-trim class="java">
public void updateAnimation(long eTime) {
	if(group.getGroup("gun") == null) { //! defensive coding
		group.addGroup((PolygonGroup)gun.clone());
	}
	changeTime -= eTime;
	if(changing &amp;&amp; changeTime &lt;= 0) {
		group.removeGroup("gun");
		group.addGroup((PolygonGroup)gun.clone());
		weaponGroup = group.getGroup("gun");
		weaponGroup.xform.velocityAngleX.set(.003f, 250);
		changing = false; //! this variable is unnecessary
	}
}
					</code></pre>
				</section>
				<section data-background="#822">
					<h1>The Worst Part</h1>
					<ul>
						<li class="fragment">changeTime</li>
						<li class="fragment">changing</li>
						<li class="fragment">weaponGroup</li>
						<li class="fragment">weaponGroup.xform.velocityAngleX</li>
					</ul>
					<p class="fragment left">
						Feels like something's missing...
					</p>
					<p class="fragment left">
						Even with all that state, there's still another variable somewhere else tracking the current weapon!
					</p>
				</section>
				<section data-background="#822">
					<h1>The Even Worse Part</h1>
					<p class="fragment">
						I never even implemented different weapon models.
					</p>
					<p class="fragment">
						Remove your dead code! It's a liability.
					</p>
				</section>
				<section data-background="#158">
					<h1>How to Improve</h1>
					<aside class="notes">
						<ul>
							<li>Remove duplicated state. It's another liability. You could do it with two variables:
								<ul>
									<li>weaponSwitchTimer</li>
									<li>weaponCurrent</li>
								</ul>
							</li>
							<li>Explicitly initialize; no defensive coding</li>
							<li>Write some darn comments.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Naming</h1>
					<pre><code data-trim class="java">
public class Ally extends GameObject {
	boolean noenemies = true; //! why
}
					</pre></code>
					<aside class="notes">
						<p>Name booleans positively</p>
						<p>Avoid "if (!noenemies)"</p>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Initialization and Error Handling</h1>
					<pre class="fragment"><code data-trim class="java">
static {
	try {
		gun = Resources.parseModel("images/gun.txt");
	} catch (FileNotFoundException e) {} //! *shrug*
	catch (IOException e) {}
}
					</code></pre>
					<aside class="notes">
						<ul>
							<li>Again, not sure when it executes</li>
							<li>Loading code scattered throughout codebase</li>
							<li>Error handling: either crash immediately or gracefully recover.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#000">
					<h1>2005-2006</h1>
					<img class="fragment" src="img/vivid.png" />
					<aside class="notes">
						<ul>
							<li>Engine built for the common man to benefit from my vast knowledge</li>
							<li>Even had tutorials</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Meshes</h1>
					<pre class="fragment"><code data-trim class="cpp">
class Mesh {
public:
	static std::list&lt;Mesh*&gt; meshes; // Static list of meshes; used for caching and rendering
	Mesh(LPCSTR file); // Loads the x file specified
	Mesh();
	Mesh(const Mesh& vMesh);
	~Mesh();
	void LoadMesh(LPCSTR xfile); // Loads the x file specified
	void DrawSubset(DWORD index); // Draws the specified subset of the mesh
	DWORD GetNumFaces(); // Returns the number of faces (triangles) in the mesh
	DWORD GetNumVertices(); // Returns the number of vertices (points) in the mesh
	DWORD GetFVF(); // Returns the Flexible Vertex Format of the mesh
	int GetNumSubsets(); // Returns the number of subsets (materials) in the mesh
	Transform transform; // World transform
	std::vector&lt;Material&gt;* GetMaterials(); // Gets the list of materials in this mesh
	std::vector&lt;Cell*&gt;* GetCells(); // Gets the list of cells this mesh is inside
	D3DXVECTOR3 GetCenter(); // Gets the center of the mesh
	float GetRadius(); // Gets the distance from the center to the outermost vertex of the mesh
	bool IsAlpha(); // Returns true if this mesh has alpha information
	bool IsTranslucent(); // Returns true if this mesh needs access to the back buffer
	void AddCell(Cell* cell); // Adds a cell to the list of cells this mesh is inside
	void ClearCells(); // Clears the list of cells this mesh is inside
protected:
	ID3DXMesh* d3dmesh; // Actual mesh data
	LPCSTR filename; // Mesh file name; used for caching
	DWORD numSubsets; // Number of subsets (materials) in the mesh
	std::vector&lt;Material&gt; materials; // List of materials; loaded from X file
	std::vector&lt;Cell*&gt; cells; // List of cells this mesh is inside
	D3DXVECTOR3 center; // The center of the mesh
	float radius; // The distance from the center to the outermost vertex of the mesh
	bool alpha; // True if this mesh has alpha information
	bool translucent; // True if this mesh needs access to the back buffer
	void SetTo(Mesh* mesh);
}
					</pre></code>
				</section>
				<section data-background="#101a26">
					<h1>You Learned: "Comments"!</h1>
					<div class="fragment">
						<p class="left">When someone tells you "comments are good", you end up writing a bunch of comments like this:</p>
						<pre><code data-trim class="cpp">
D3DXVECTOR3 GetCenter(); // Gets the center of the mesh
						</pre></code>
					</div>
				</section>
				<section data-background="#101a26">
					<h1>You Learned: "Object-Oriented Programming"!</h1>
					<pre class="fragment"><code data-trim class="cpp">
// Returns true if this mesh has alpha information
bool Mesh::IsAlpha() {
	return alpha;
}
// Returns true if this mesh needs access to the back buffer
bool Mesh::IsTranslucent() {
	return translucent;
}
// Returns the number of faces (triangles) in the mesh
DWORD Mesh::GetNumFaces() {
	return d3dmesh-&gt;GetNumFaces();
}
// Returns the number of vertices (points) in the mesh
DWORD Mesh::GetNumVertices() {
	return d3dmesh-&gt;GetNumVertices();
}
// ...
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Unloading a Mesh</h1>
					<pre class="fragment"><code data-trim class="cpp">
std::list&lt;Mesh*&gt; Mesh::meshes;

Mesh::~Mesh() {
	// Iterate through all the meshes
	std::list&lt;Mesh*&gt;::iterator i = meshes.begin();
	while(i != meshes.end()) { //! deleting all meshes is O(n^2)
		if(*i == this) {
			meshes.erase(i); // Erase this object from the list so we don't have a stray pointer in the mesh list
			break;
		}
		i++;
	} //! unclear who owns this mesh
	materials.clear();
	vvd::Release&lt;ID3DXMesh*&gt;(d3dmesh); // Release the mesh data
}
					</pre></code>
				</section>
				<section data-background="#822">
					<h1>Problems</h1>
					<aside class="notes">
						<ul>
							<li>Poor OOP design leads to weird unintuitive patterns, like an object "deleting itself" or "serializing itself".</li>
							<li>No real-world equivalent; it does too much</li>
							<li>SetTo() function necessary for copying data; it's too smart, hard to move around</li>
							<li>90% of comments useless. Another liability.</li>
							<li>Getters and setters.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>How to Improve</h1>
					<aside class="notes">
						<ul>
							<li>Think of a mesh as inert data. It has no functionality.</li>
							<li>Instead of making each mesh super smart, write a resource manager.</li>
							<li>That clears up who's responsible for what.</li>
							<li>Make all fields public.</li>
							<li>Delete comments that explain what the code does.</li>
							<li>Write comments that explain why.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#000">
					<h1>2007-2008</h1>
					<p class="fragment">PHP dark ages</p>
					<img class="fragment" src="img/php.png" />
				</section>
				<section data-background="#000">
					<h1>2009-2010</h1>
					<img class="fragment" src="img/a3p.jpg" />
					<aside class="notes">
						<p>No excuse by this point</p>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Globals</h1>
					<aside class="notes">
						<ul>
							<li>Use case: in update function, need to query for an entity.</li>
							<li>Common wisdom: globals are evil</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>What's Wrong With Globals?</h1>
					<aside class="notes">
						<ul>
							<li>Can lead to spaghetti code</li>
							<li>Function "A" can break a completely unrelated function "B" by modifying global state</li>
							<li>Doesn't work with threads</li>
							<li>Moral of the story: avoid globals</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>What Happens When You Try to Avoid Globals</h1>
					<div class="fragment">
						<p class="left">You pass everything as parameters</p>
						<pre><code data-trim class="python">
def serverUpdate(self, aiWorld, entityGroup, packetUpdate):
	# ...
						</code></pre>
					</div>
				</section>
				<section data-background="#158">
					<h1>This Will Be Great</h1>
					<p>I could have multiple EntityGroups! Multiple worlds!</p>
				</section>
				<section data-background="#822">
					<h1>Reality</h1>
					<aside class="notes">
						<ul>
							<li>If every object has access to it, it's still a global.</li>
							<li>You Aren't Gonna Need It.</li>
							<li>When you add a new system, you'll be lazy and just tack it on to an existing object</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>What About a Singleton?</h1>
					<pre class="fragment"><code data-trim class="java">
class Thing
{
	public static Thing Instance()
	{
		static Thing i = null;
		if (i == null)
			i = Thing();
		return i;
	}
}

Thing.Instance().DoThing();
					</pre></code>
					<p class="fragment">It's technically not a global!</p>
				</section>
				<section data-background="#822">
					<h1>Reality</h1>
					<aside class="notes">
						<ul>
							<li>It's still a global. You're just lying to yourself.</li>
							<li>Singletons are actually worse.</li>
							<li>You don't know when a singleton will be initialized.</li>
							<li>Every time you access a singleton, it's a branch.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Just Use Globals</h1>
					<aside class="notes">
						<ul>
							<li>If it needs to be global, make it global. Takes experience to know.</li>
							<li>Real problem is code interdependence</li>
							<li>Most gameplay code is necessarily interdependent; make it a cohesive system.</li>
							<li>Think of a game as a series of systems with well-defined boundaries. AI, graphics, etc.</li>
							<li>Good way to separate a system: put it on a thread w/ communication protocol.</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Boolean Parameters</h1>
					<pre class="fragment"><code data-trim class="python">
class ObjectEntity:
	def delete(self, entityGroup, killed, local):
		# ...
		if killed:
			# ...
		if local:
			# ...
					</code></pre>
					<aside class="notes">
						<p>Tempting to just tack on a boolean parameter for similar functionality</p>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Client Code</h1>
					<pre><code data-trim class="python">
object.delete(entityGroup, True, False)
					</code></pre>
					<aside class="notes">
						<p>It's unreadable.</p>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Improved</h1>
					<pre><code data-trim class="python">
entityGroup.deleteLocal(object)
entityGroup.deleteRemote(object)
entityGroup.killLocal(object)
entityGroup.killRemote(object)
					</code></pre>
					<aside class="notes">
						<p>Always write the client code first.</p>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Another Option: Flags</h1>
					<pre class="fragment"><code data-trim class="cpp">
entity_group.remove(e, EntityDeleteLocal | EntityDeleteKilled);
					</code></pre>
					<p class="fragment">Be careful, these can get out of hand</p>
				</section>
				<section data-background="#101a26">
					<h1>Naming</h1>
					<pre class="fragment"><code data-trim class="python">
class TeamEntityController(Controller):

	def buildSpawnPacket(self):
		# ...
	
	def readSpawnPacket(self):
		# ...
	
	def serverUpdate(self):
		# ...

	def clientUpdate(self):
		# ...
					</pre></code>
					<aside class="notes">
						<p>One of the most important remaining unsolved problems in CS</p>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Ordering: General -> Specific</h1>
					<p>Helps with code completion and organization.</p>
					<pre><code data-trim class="python">
class TeamEntityController(Controller):

	def packetSpawnBuild(self):
		# ...
	
	def packetSpawnRead(self):
		# ...
	
	def updateServer(self):
		# ...

	def updateClient(self):
		# ...
					</pre></code>
				</section>
				<section data-background="#000">
					<h1>2010 - 2015</h1>
					<img class="fragment" src="img/lemma.jpg" />
					<aside class="notes">
						<ul>
							<li>First game actually finished, only took 12 years</li>
							<li>Not many small mistakes, but lots of the biggest ones</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Data Binding</h1>
					<aside class="notes">
						<ul>
							<li>Examples: MVVM, React, Angular</li>
							<li>The dream: set a variable, textbox updates automatically</li>
						</ul>
					</aside>
				</section>
				<section data-background="#000">
					<h1>The Dream</h1>
					<input style="width: 100%; display: block;" type="textbox" id="src" />
					<div>Hello, <span id="dst"></span></div>
				</section>
				<section data-background="#101a26">
					<h1>The Dream</h1>
					<pre><code data-trim class="csharp">
public class Player
{
	public Property&lt;string&gt; Name = new Property&lt;string&gt; { Value = "Ryu" };
}

public class TextElement : UIComponent
{
	public Property&lt;string&gt; Text = new Property&lt;string&gt; { Value = "" };
}

label.add(new Binding&lt;string&gt;(label.Text, player.Name));
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Red Flags</h1>
					<pre><code data-trim class="csharp">
public class Property&lt;Type&gt; : IProperty
{
	protected Type _value;
	protected List&lt;IPropertyBinding&gt; bindings; //! inefficient

	public Type Value
	{
		get { return this._value; }
		set
		{
			this._value = value;
			//! weird loop necessary due to binding changes
			for (int i = this.bindings.Count - 1; i &gt;= 0; i = Math.Min(this.bindings.Count - 1, i - 1))
				this.bindings[i].OnChanged(this);
		}
	}
}
					</code></pre>
				</section>
				<section data-background="#101a26">
					<h1>Taking Things Too Far</h1>
					<pre><code data-trim class="csharp">
jump.Add(new Binding&lt;bool&gt;(jump.Crouched, player.Character.Crouched));
jump.Add(new TwoWayBinding&lt;bool&gt;(player.Character.IsSupported, jump.IsSupported));
jump.Add(new TwoWayBinding&lt;bool&gt;(player.Character.HasTraction, jump.HasTraction));
jump.Add(new TwoWayBinding&lt;Vector3&gt;(player.Character.LinearVelocity, jump.LinearVelocity));
jump.Add(new TwoWayBinding&lt;BEPUphysics.Entities.Entity&gt;(jump.SupportEntity, player.Character.SupportEntity));
jump.Add(new TwoWayBinding&lt;Vector3&gt;(jump.SupportVelocity, player.Character.SupportVelocity));
jump.Add(new Binding&lt;Vector2&gt;(jump.AbsoluteMovementDirection, player.Character.MovementDirection));
jump.Add(new Binding&lt;WallRun.State&gt;(jump.WallRunState, wallRun.CurrentState));
jump.Add(new Binding&lt;float&gt;(jump.Rotation, rotation.Rotation));
jump.Add(new Binding&lt;Vector3&gt;(jump.Position, transform.Position));
jump.Add(new Binding&lt;Vector3&gt;(jump.FloorPosition, floor));
jump.Add(new Binding&lt;float&gt;(jump.MaxSpeed, player.Character.MaxSpeed));
jump.Add(new Binding&lt;float&gt;(jump.JumpSpeed, player.Character.JumpSpeed));
jump.Add(new Binding&lt;float&gt;(jump.Mass, player.Character.Mass));
jump.Add(new Binding&lt;float&gt;(jump.LastRollKickEnded, rollKickSlide.LastRollKickEnded));
jump.Add(new Binding&lt;Voxel&gt;(jump.WallRunMap, wallRun.WallRunVoxel));
jump.Add(new Binding&lt;Direction&gt;(jump.WallDirection, wallRun.WallDirection));
jump.Add(new CommandBinding&lt;Voxel, Voxel.Coord, Direction&gt;(jump.WalkedOn, footsteps.WalkedOn));
jump.Add(new CommandBinding(jump.DeactivateWallRun, (Action)wallRun.Deactivate));
jump.FallDamage = fallDamage;
jump.Predictor = predictor;
jump.Bind(model);
jump.Add(new TwoWayBinding&lt;Voxel&gt;(wallRun.LastWallRunMap, jump.LastWallRunMap));
jump.Add(new TwoWayBinding&lt;Direction&gt;(wallRun.LastWallDirection, jump.LastWallDirection));
jump.Add(new TwoWayBinding&lt;bool&gt;(rollKickSlide.CanKick, jump.CanKick));
jump.Add(new TwoWayBinding&lt;float&gt;(player.Character.LastSupportedSpeed, jump.LastSupportedSpeed));

wallRun.Add(new Binding&lt;bool&gt;(wallRun.IsSwimming, player.Character.IsSwimming));
wallRun.Add(new TwoWayBinding&lt;Vector3&gt;(player.Character.LinearVelocity, wallRun.LinearVelocity));
wallRun.Add(new TwoWayBinding&lt;Vector3&gt;(transform.Position, wallRun.Position));
wallRun.Add(new TwoWayBinding&lt;bool&gt;(player.Character.IsSupported, wallRun.IsSupported));
wallRun.Add(new CommandBinding(wallRun.LockRotation, (Action)rotation.Lock));
wallRun.Add(new CommandBinding&lt;float&gt;(wallRun.UpdateLockedRotation, rotation.UpdateLockedRotation));
vault.Add(new CommandBinding(wallRun.Vault, delegate() { vault.Go(true); }));
wallRun.Predictor = predictor;
wallRun.Add(new Binding&lt;float&gt;(wallRun.Height, player.Character.Height));
wallRun.Add(new Binding&lt;float&gt;(wallRun.JumpSpeed, player.Character.JumpSpeed));
wallRun.Add(new Binding&lt;float&gt;(wallRun.MaxSpeed, player.Character.MaxSpeed));
wallRun.Add(new TwoWayBinding&lt;float&gt;(rotation.Rotation, wallRun.Rotation));
wallRun.Add(new TwoWayBinding&lt;bool&gt;(player.Character.AllowUncrouch, wallRun.AllowUncrouch));
wallRun.Add(new TwoWayBinding&lt;bool&gt;(player.Character.HasTraction, wallRun.HasTraction));
wallRun.Add(new Binding&lt;float&gt;(wallRun.LastWallJump, jump.LastWallJump));
wallRun.Add(new Binding&lt;float&gt;(player.Character.LastSupportedSpeed, wallRun.LastSupportedSpeed));
player.Add(new Binding&lt;WallRun.State&gt;(player.Character.WallRunState, wallRun.CurrentState));

input.Bind(rollKickSlide.RollKickButton, settings.RollKick);
rollKickSlide.Add(new Binding&lt;bool&gt;(rollKickSlide.EnableCrouch, player.EnableCrouch));
rollKickSlide.Add(new Binding&lt;float&gt;(rollKickSlide.Rotation, rotation.Rotation));
rollKickSlide.Add(new Binding&lt;bool&gt;(rollKickSlide.IsSwimming, player.Character.IsSwimming));
rollKickSlide.Add(new Binding&lt;bool&gt;(rollKickSlide.IsSupported, player.Character.IsSupported));
rollKickSlide.Add(new Binding&lt;Vector3&gt;(rollKickSlide.FloorPosition, floor));
rollKickSlide.Add(new Binding&lt;float&gt;(rollKickSlide.Height, player.Character.Height));
rollKickSlide.Add(new Binding&lt;float&gt;(rollKickSlide.MaxSpeed, player.Character.MaxSpeed));
rollKickSlide.Add(new Binding&lt;float&gt;(rollKickSlide.JumpSpeed, player.Character.JumpSpeed));
rollKickSlide.Add(new Binding&lt;Vector3&gt;(rollKickSlide.SupportVelocity, player.Character.SupportVelocity));
rollKickSlide.Add(new TwoWayBinding&lt;bool&gt;(wallRun.EnableEnhancedWallRun, rollKickSlide.EnableEnhancedRollSlide));
rollKickSlide.Add(new TwoWayBinding&lt;bool&gt;(player.Character.AllowUncrouch, rollKickSlide.AllowUncrouch));
rollKickSlide.Add(new TwoWayBinding&lt;bool&gt;(player.Character.Crouched, rollKickSlide.Crouched));
rollKickSlide.Add(new TwoWayBinding&lt;bool&gt;(player.Character.EnableWalking, rollKickSlide.EnableWalking));
rollKickSlide.Add(new TwoWayBinding&lt;Vector3&gt;(player.Character.LinearVelocity, rollKickSlide.LinearVelocity));
rollKickSlide.Add(new TwoWayBinding&lt;Vector3&gt;(transform.Position, rollKickSlide.Position));
rollKickSlide.Predictor = predictor;
rollKickSlide.Bind(model);
rollKickSlide.VoxelTools = voxelTools;
rollKickSlide.Add(new CommandBinding(rollKickSlide.DeactivateWallRun, (Action)wallRun.Deactivate));
rollKickSlide.Add(new CommandBinding(rollKickSlide.Footstep, footsteps.Footstep));
					</code></pre>
				</section>
				<section data-background="#822">
					<h1>Problem: Initialization</h1>
					<aside class="notes">
						<ul>
							<li>Infinite loops</li>
							<li>Initialization order is important</li>
							<li>Never figured this out</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>Problem: Animation</h1>
					<aside class="notes">
						<ul>
							<li>Difficult to animate from one state to another</li>
							<li>Netflix's actual React solution: disable, animate, then re-enable</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Binding On/Off Switch</h1>
					<pre><code data-trim class="csharp">
class Binding&lt;T&gt;
{
	public bool Enabled;
}
					</code></pre>
					<aside class="notes">
						<ul>
							<li>Goal of data binding is to reduce state</li>
							<li>But every property has a LIST of bindings and every binding has a boolean</li>
							<li>How can we reduce this state?</li>
						</ul>
					</aside>
				</section>
				<section data-background="#101a26">
					<h1>Solution</h1>
					<pre><code data-trim class="csharp">
class Binding&lt;T&gt;
{
	public Property&lt;bool&gt; Enabled = new Property&lt;bool&gt; { Value = true };
}
					</code></pre>
				</section>
				<section data-background="#822">
					<h1>Data Binding</h1>
					<p>So close but so far</p>
					<aside class="notes">
						<ul>
							<li>Goal is to reduce state, like functional programming</li>
							<li>Actually creates more state</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>How to Improve</h1>
					<aside class="notes">
						<ul>
							<li>Make UI actually functional and stateless (immediate UI)</li>
							<li>It should be a pain to create state</li>
							<li>Separate behavior and state</li>
						</ul>
					</aside>
				</section>
				<section data-background="#822">
					<h1>Etc., etc.</h1>
					<aside class="notes">
						<ul>
							<li>Another creative approach to globals</li>
							<li>Closures</li>
							<li>"Entity" "Component" "System"</li>
							<li>"Multithreading"</li>
							<li>No time</li>
						</ul>
					</aside>
				</section>
				<section data-background="#158">
					<h1>Takeaways</h1>
					<ol>
						<li class="fragment">Make decisions upfront instead of lazily leaving them to the computer.</li>
						<li class="fragment">Separate behavior and state.</li>
						<li class="fragment">Write pure functions.</li>
						<li class="fragment">Write the client code first.</li>
						<li class="fragment">Write boring code.</li>
					</ol>
				</section>
				<section data-background="#185">
					<h1>Disclaimers</h1>
					<ul>
						<li class="fragment">Only a Sith deals in absolutes.</li>
						<li class="fragment">Avoid dogma.</li>
						<li class="fragment">Avoid shiny tools and patterns.</li>
						<li class="fragment">Avoid holy wars.</li>
						<li class="fragment">Tabs are better than spaces.</li>
					</ul>
				</section>
				<section data-background="#000">
					<h1>Thank you!</h1>
					<p><a href="https://etodd.github.io/bad-code">etodd.github.io/bad-code</a></p>
					<p><a href="http://etodd.io/">etodd.io</a></p>
				</section>
			</div>
		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>
		<script>
			Reveal.initialize(
			{
				controls: false,
				progress: true,
				history: true,
				center: true,
				transition: 'slide',
				backgroundTransition: 'slide',
				transitionSpeed: 'superfast',
				dependencies:
				[
					{
						src: 'reveal.js/plugin/highlight/highlight.js',
						async: false,
						callback: function()
						{
							hljs.initHighlighting();

							var comments = document.querySelectorAll('.hljs-comment');
							for (var i = 0; i < comments.length; i++)
							{
								for (var j = 1; j < 5; j++)
								{
									var code = comments[i].innerText.substr(j, 1);
									if (code === '!')
										comments[i].classList.add('bad');
									if (code === '!' || code === '@')
									{
										comments[i].classList.add('fragment');
										break;
									}
								}
							}
						}
					},
					{ src: 'reveal.js/plugin/notes/notes.js', async: false },
				],
			});

			(function()
			{
				var dst = document.getElementById('dst');
				document.getElementById('src').addEventListener('keyup', function()
				{
					dst.innerText = this.value;
				});
			})();

			if (window.location.search.match(/print-pdf/gi))
				$('head').append($('<link rel="stylesheet" type="text/css" href="reveal.js/css/print/pdf.css" />'));
		</script>
	</body>
</html>
